* Criar threads (passive e ativa): 
  A thread passiva sera responsavel por receber "ordens", enquanto a ativa
  vai submeter ordens.
  
  Na inicializacao as duas threads sao criadas. Quando o processo for master ele
  vai enviar requisicao para todos os slaves, desta forma ficando todo mundo preparado. 
  Caso o processo for slave, a thread passiva vai ficar aguradando o master.
  
  Master
    Thread ativa = envia requisicao para slaves
    Thread passiva = aguarda resposta de slaves
    
  Slaves
    Thread ativa = envia resposta para master
    Thread passiva = aguarda ordens do master


* Usar variaveis condicionais. engine coloca valor em buffer compartilhado, ativa variavel
condicional, remote pega lock e usa buffer, limpando buffer e alterando status do slave_status
usado.


Talvez trocar o status de EXECUTING para EXECUTING_REMOTE



Mensagens

MASTER										SLAVE
NEW_TASK									OK (status: WAITING_TASK_DESC)
TASK_DESC									OK (status: EXECUTING)
									OK (status: EXECUTING)
---
continue executing

MASTER										SLAVE
NEW_TASK (recv OK)				OK (recv WAITING_TASK_DESC)
TASK_DESC (recv OK)				OK (recv WAITING_TASK_DATA)


MASTER																			SLAVE
send(NEW_TASK) - wait(OK)										wait(NEW_TASK) - send(OK) - wait(TASK_DESC)
send(TASK_DESC) - wait(OK) - wait(RESULT)		send(OK) - execute_task... - send(RESULT)